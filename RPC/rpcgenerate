#!/bin/env python3

from idl_to_json import idl_to_json
import sys
import json
import re
import bisect 
from functools import reduce

STD_READ_SIZE = 20
FUNC_CALL_BUFFER_SIZE = 50000

built_in_types = [ "void", "int", "string", "float" ]
static_size_types = [ "int", "float" ]

###### parse_array_type_name
## 
## Takes a string of the form __<type>[<num>]{[<num>]} and parses
## it into a tuple of the form ('<type>', ['<num>', ...]).
##
## Example: "__int[4][10][100]" --> ("int", ["4", "10", "100"])
##
######
def parse_array_type_name(tname):
    res = [ x for x in re.split('__|\[|\]', tname) if x != "" ]
    return (res[0], res[1:])

###### create_new_array_type_name
## 
## Takes a a tuple of the form ('<type>', ['<num>', ...]) and
## produces a string of the form Array_<type>_<num>{_<num>}.
##
## Example: ("int", ["4", "10", "100"]) --> "Array_int_4_10_100"
##
######
def create_new_array_type_name(type_info):
    res = f"Array_{type_info[0]}"
    for dimension in type_info[1]:
        res += f"_{dimension}"

    return res

###### idl_string_to_python_object
## 
## Takes a string containing the contents of a JSON-parsed idl file,
## preprocesses the string, and returns a Python object representing
## the idl data.
##
## Preprocessing includes replacing all array type names with custom
## versions that can be used in C++ function names.
##
## Example: The type name "__int[4][10][100]"" can't be used in a
## function name like so:
##
##     int* deserialize___int[4][10][100](string x)
##
## So, we can use "Array_int_4_10_100" to represent the type instead:
##
##     int* deserialize_Array_int_4_10_100(string x)
##
######
def idl_string_to_python_object(idl_str):
    unclean_idl_obj = json.loads(idl_str)
    replacements = []
    for tname, info in unclean_idl_obj["types"].items():
        if info["type_of_type"] == "array":
            # Create a new name representing this array type...
            new_array_type_name = create_new_array_type_name(parse_array_type_name(tname))

            # If the name we created is already in use...
            if new_array_type_name in unclean_idl_obj["types"]:
                # Append a number to the name until it is unique.
                tiebreaker = new_array_type_name
                i = 0
                while tiebreaker in unclean_idl_obj["types"]:
                    tiebreaker = new_array_type_name + f"_v{i}"
                    i += 1
                new_array_type_name = tiebreaker
            bisect.insort(replacements, (tname, new_array_type_name))
    
    # Replace the largest type names before the smaller ones to
    # avoid the prefixes of larger onces being replaced when
    # replacing smaller ones.
    replacements.reverse()
    for (tname, replacement) in replacements:
        idl_str = idl_str.replace(tname, replacement)

    return json.loads(idl_str)

def find_root_type_of_array(typename, idl_types_data):
    if idl_types_data[typename]["type_of_type"] != "array":
        return typename

    return find_root_type_of_array(idl_types_data[typename]["member_type"], idl_types_data)

def create_non_array_serialize(type_name, idl_types_data):
    function = f"\nstring serialize_{type_name}({type_name} x) {{\n"
    signature = function[:-3] + ';';
    function += "    string data = \"\";\n"
    for member in idl_types_data[type_name]["members"]:
        function += f"    data += serialize_{member['type']}(x.{member['name']});\n"
    function += "    return serialize_int((int)data.length()) + data;\n"
    function += "}\n"

    return (signature, function)

def create_non_array_deserialize(type_name, idl_types_data):
    function = f"\n{type_name} deserialize_{type_name}(string x) {{\n"
    signature = function[:-3] + ';';
    function += f"    {type_name} new_item;\n"
    function += "    int len = sizeof(int);\n"
    for member in idl_types_data[type_name]["members"]:
        function += f"\n    x = x.substr(len);\n"
        if member['type'] not in static_size_types:
            function += f"    len = sizeof(int) + deserialize_int(x.substr(0, sizeof(int)));\n"
        else:
            function += f"    len = sizeof({member['type']});\n"
        if idl_types_data[member['type']]['type_of_type'] != 'array':
            function += f"    new_item.{member['name']} = deserialize_{member['type']}(x.substr(0, len));\n"
        else:
            function += f"    deserialize_{member['type']}(x.substr(0, len), ({find_root_type_of_array(member['type'], idl_types_data)}*)new_item.{member['name']});\n"
    function += "\n    return new_item;\n"
    function += "}\n"

    return (signature, function)

def parse_array_name(arr_name, idl_types_data):
    root_ty = find_root_type_of_array(arr_name, idl_types_data)

    arr_name = arr_name.replace(root_ty, "")
    sects = arr_name.split('_')
    
    dimens = [ x for x in sects if re.match('\d+', x) != None ]
    
    return (root_ty, dimens)

def create_cpp_array_type_string(root_ty, dimens, name='x'):
    ret = f"{root_ty} {name}"
    for d in dimens:
        ret += f"[{d}]"
    return ret

def create_array_serialize(type_name, idl_types_data):
    
    root_ty, dimens = parse_array_name(type_name, idl_types_data)

    arg = create_cpp_array_type_string(root_ty, dimens)
   
    function = f"\nstring serialize_{type_name}({arg}) {{\n"
    signature = function[:-3] + ';';
    function += "    string data = \"\";\n"
    function += f"    for (int i = 0; i < {idl_types_data[type_name]['element_count']}; i++) {{\n"
    function += f"        data += serialize_{idl_types_data[type_name]['member_type']}(x[i]);\n"
    function += "    }\n"
    function += "    return serialize_int((int)data.length()) + data;\n"
    function += "}\n"

    return (signature, function)

def create_array_deserialize(type_name, idl_types_data):
    
    root_ty, dimens = parse_array_name(type_name, idl_types_data)

    ret = create_cpp_array_type_string(root_ty, dimens)

    member_root_ty, member_dimens = parse_array_name(idl_types_data[type_name]['member_type'], idl_types_data)

    arg = root_ty + ''.join(['*' for _ in dimens])



    function = f"\nvoid deserialize_{type_name}(string x, {root_ty}* dest) {{\n"
    signature = function[:-3] + ';';
    function += f"    int len = sizeof(int);\n"
    function += f"    x = x.substr(len);\n"
    function += f"\n    for (int i = 0; i < {idl_types_data[type_name]['element_count']}; i++) {{\n"
    if idl_types_data[type_name]['member_type'] not in static_size_types:
        function += f"        len = sizeof(int) + deserialize_int(x.substr(0, sizeof(int)));\n"
    else:
        function += f"        len = sizeof({idl_types_data[type_name]['member_type']});\n"
    if idl_types_data[idl_types_data[type_name]['member_type']]['type_of_type'] != 'array':
        function += f"        dest[i] = deserialize_{idl_types_data[type_name]['member_type']}(x.substr(0, len));\n"
    else:
        num_elems_in_next_arr = reduce(lambda a, b: a * b, [int(x) for x in member_dimens])
        next_arr_elem_ty = member_root_ty + ''.join(['*' for _ in member_dimens])
        function += f"        deserialize_{idl_types_data[type_name]['member_type']}(x.substr(0, len), dest + (i * { num_elems_in_next_arr }));\n"
    function += f"        x = x.substr(len);\n"
    function += "    }\n"
    function += "}\n"
    return (signature, function)


def create_serializers(idl_types_data, idl_name, idl_path):
    requirements = ("#include <string>\n"
                    "#include <arpa/inet.h>\n"
                    "#include <sstream>\n"
                    "#include <iostream>\n"
                    "using namespace std;\n"
                    f"#ifndef {idl_name}\n"
                    f"#define {idl_name}\n"
                    f"#include \"{idl_path}\"\n"
                    "#endif\n"
                    "\n"
                    "union FloatInt {\n"
                    "  uint32_t i;\n"
                    "  float f;\n"
                    "};\n")
    funcs = {
        "int" : {
            "serializer" : {
                "name" : "serialize_int",
                "signature" : "\nstring serialize_int(int x);",
                "definition" : ("\nstring serialize_int(int x) {\n"
                                "  uint32_t network_x = htonl((uint32_t)x);\n"
                                "  stringstream sstream;\n"
                                "  const char* ptr = reinterpret_cast<char*>(&network_x);\n"
                                "  sstream.write(ptr, sizeof(network_x));\n"
                                "  return sstream.str();\n"
                                "}\n")
            },
            "deserializer" : {
                "name" : "deserialize_int",
                "signature" : "\nint deserialize_int(string x);",
                "definition" : ("\nint deserialize_int(string x) {\n"
                                "  uint32_t new_item;\n"
                                "  std::stringstream ss(x);\n"
                                "  ss.read(reinterpret_cast<char*>(&new_item), sizeof(new_item));\n"
                                "  return (int)ntohl(new_item);\n"
                                "}\n")
            }
        },
        "string" : {
            "serializer" : {
                "name" : "serialize_string",
                "signature" : "\nstring serialize_string(string x);",
                "definition" : ("\nstring serialize_string(string x) {\n"
                                "  return serialize_int((int)x.length()) + x;\n"
                                "}\n")
            },
            "deserializer" : {
                "name" : "deserialize_string",
                "signature" : "\nstring deserialize_string(string x);",
                "definition" : ("\nstring deserialize_string(string x) {\n"
                                "  int str_size = deserialize_int(x.substr(0, sizeof(int)));\n"
                                "  return x.substr(sizeof(int), str_size);\n"
                                "}\n")
            }
        },
        "float" : {
            "serializer" : {
                "name" : "serialize_float",
                "signature" : "\nstring serialize_float(float x);",
                "definition" : ("\nstring serialize_float(float x) {\n"
                                "  FloatInt conv;\n"
                                "  conv.f = x;\n"
                                "  return serialize_int((int)conv.i);\n"
                                "}\n")
            },
            "deserializer" : {
                "name" : "deserialize_float",
                "signature" : "\nfloat deserialize_float(string x);",
                "definition" : ("\nfloat deserialize_float(string x) {\n"
                                "  int new_item = deserialize_int(x);\n"
                                "  FloatInt conv;\n"
                                "  conv.i = (uint32_t)new_item;\n"
                                "  return conv.f;\n"
                                "}\n")
            }
        }
    }

    for ty in idl_types_data:
        if idl_types_data[ty]["type_of_type"] != "builtin":
            funcs[ty] = {
                "serializer" : {
                    "name" : f"serialize_{ty}",
                    "definition" : ""
                },
                "deserializer" : {
                    "name" : f"deserialize_{ty}",
                    "definition" : ""
                }
            }

    for ty in idl_types_data:
        if idl_types_data[ty]["type_of_type"] != "builtin":
            if idl_types_data[ty]["type_of_type"] != "array":
                ssig, sfunc = create_non_array_serialize(ty, idl_types_data)
                dsig, dfunc = create_non_array_deserialize(ty, idl_types_data)
                funcs[ty]["serializer"]["definition"] = sfunc
                funcs[ty]["serializer"]["signature"] = ssig
                funcs[ty]["deserializer"]["definition"] = dfunc
                funcs[ty]["deserializer"]["signature"] = dsig
            else:
                ssig, sfunc = create_array_serialize(ty, idl_types_data)
                dsig, dfunc = create_array_deserialize(ty, idl_types_data)
                funcs[ty]["serializer"]["definition"] = sfunc
                funcs[ty]["serializer"]["signature"] = ssig
                funcs[ty]["deserializer"]["definition"] =  dfunc
                funcs[ty]["deserializer"]["signature"] = dsig

    return { "requirements" : requirements, "functions" : funcs }

def create_proxy_function(name, idl_data):
    ret_ty = idl_data['functions'][name]['return_type']
    args = ""

    # If the function has any arguments...
    if len(idl_data['functions'][name]['arguments']) > 0:

        # For each argument...
        for i in range(len(idl_data['functions'][name]['arguments'])):
            arg_type = idl_data['functions'][name]['arguments'][i]['type']
            arg_name = idl_data['functions'][name]['arguments'][i]['name']

            # If the argument is an array...
            if idl_data['types'][arg_type]['type_of_type'] == 'array':

                # Create the cpp-friendly version of the type name... Array_int_4_10 --> int x[4][10]
                root_ty, dimens = parse_array_name(arg_type, idl_data['types'])
                arr_ty = create_cpp_array_type_string(root_ty, dimens, arg_name)
                args += f", {arr_ty}"
            else:

                # Otherwise add it normally...
                args += f", {arg_type} {arg_name}"

    function = f"\n{ret_ty} {name}({args[2:]}) {{\n"
    sig = function[1:-3] + ';\n'

    function += "    char readBuffer[STD_READ_SIZE];\n"
    function += "    readBuffer[0] = 'J';  // sanity check\n"
    function += "    NetworkFormatter f = NetworkFormatter();\n"
    function += f'    f.setFunctionName("{name}");\n'

    ret_ty_size_str = ""
    if ret_ty in static_size_types:
        ret_ty_size_str = f"sizeof({ret_ty})"
    else:
        ret_ty_size_str = "-1"
    
    function += f'    f.setFunctionRetType("{ret_ty}", {ret_ty_size_str});\n'

    for i in range(len(idl_data['functions'][name]['arguments'])):
        arg_type = idl_data['functions'][name]['arguments'][i]['type']
        arg_name = idl_data['functions'][name]['arguments'][i]['name']
        arg_size_str = ""
        if arg_type in static_size_types:
            arg_size_str = f"sizeof({arg_type})"
        else:
            arg_size_str = "-1"

        function += f'    f.appendArg("{arg_type}", {arg_size_str}, serialize_{arg_type}({arg_name}));\n'
    
    function += "    string data = f.networkForm();\n"
    function += "    RPCPROXYSOCKET->write(data.c_str(), data.length());\n"
    function += "    RPCPROXYSOCKET->read(readBuffer, 1);\n"
    function += "    if (readBuffer[0] != '0') {\n"
    function += f'        throw C150Exception("{sig[:-2]}: call not recognized by the server.");\n'
    function += '    }\n'

    if ret_ty in static_size_types:
        function += f"    RPCPROXYSOCKET->read(readBuffer, sizeof({ret_ty}));\n"
        function += f"    string resultStr(readBuffer, sizeof({ret_ty}));\n"
        function += f"    return deserialize_{ret_ty}(resultStr);\n"
    elif ret_ty == "void":
        function += '   return;\n'   
    else:
        function += "    RPCPROXYSOCKET->read(readBuffer, sizeof(int));\n"
        function += "    string lenStr(readBuffer, sizeof(int));\n"
        function += "    int len = deserialize_int(lenStr);\n"
        function += "    char dataBuffer[len];\n"
        function += "    RPCPROXYSOCKET->read(dataBuffer, len);\n"
        function += "    string resultStr(dataBuffer, len);\n"
        function += "    resultStr = lenStr + resultStr;\n"
        function += f"    return deserialize_{ret_ty}(resultStr);\n"

    function += "}\n"

    return (sig, function)

def create_proxy_functions(idl_data):
    requirements = ("#include \"rpcproxyhelper.h\"\n"
                    "#include \"c150debug.h\"\n"
                    f"#define STD_READ_SIZE {STD_READ_SIZE}\n"
                    "using namespace C150NETWORK;\n")

    funcs = []

    for fname in idl_data['functions']:
        sig, definition = create_proxy_function(fname, idl_data)
        func_obj = { 
            "name" : fname,
            "signature" : sig,
            "definition" : definition
        }

        funcs.append(func_obj)

    return { "requirements" : requirements, "functions" : funcs }

def get_comparable_func_signature(fname, idl_data):
    ret_ty_str = idl_data['functions'][fname]['return_type']
    if idl_data['functions'][fname]['return_type'] in static_size_types:
        ret_ty_str += '(4)'
    else:
        ret_ty_str += '(-1)'

    components = [fname, ret_ty_str]
    for arg in idl_data['functions'][fname]['arguments']:
        arg_ty_str = arg['type']
        if arg['type'] in static_size_types:
            arg_ty_str += '(4)'
        else:
            arg_ty_str += '(-1)'
        components.append(arg_ty_str)
    
    return ','.join(components)



def create_dispatch_function(idl_data):
    
    function = "\nvoid dispatchFunction() {\n"
    function += f"  char numBytesBuf[sizeof(int)];\n"
    function += "  int numBytesIncoming = sizeof(numBytesBuf) + getNumBytesInIncomingFunctionCall(numBytesBuf);\n"
    function += "  if (numBytesIncoming == sizeof(numBytesBuf)) return;\n"
    function += " char functionCallBuffer[numBytesIncoming];\n"
    function += "  for (size_t i = 0; i < sizeof(numBytesBuf); i++) {\n"
    function += "    functionCallBuffer[i] = numBytesBuf[i];\n"
    function += "  }\n"
    function += "  int numBytesRead = getFunctionCallFromStream(functionCallBuffer,sizeof(functionCallBuffer));\n"
    function += "  if (numBytesRead == 0) return;\n"
    function += "  string offTheWire(functionCallBuffer, sizeof(int) + numBytesRead);\n"
    function += "  NetworkFormatter f = NetworkFormatter(offTheWire);\n"
    function += "  if (!RPCSTUBSOCKET-> eof()) {\n"
   
    if len(idl_data['functions'].keys()) == 0:
        function += "    __badFunction();\n"
    else:
        fnames = list(idl_data['functions'].keys())
        for i in range(len(fnames)):
            s = get_comparable_func_signature(fnames[i], idl_data)
            if i == 0:
                function += f"    if (f.getFunctionSignature() == \"{s}\") {{\n"
            else:
                function += f"    }} else if (f.getFunctionSignature() == \"{s}\") {{\n"

            arg_names = []
            j = 0
            for arg in idl_data['functions'][fnames[i]]['arguments']:
                arg_declaration = ""
                if idl_data['types'][arg['type']]['type_of_type'] != 'array':
                    arg_declaration = f"{arg['type']} {arg['name']}"
                    function += f"      {arg_declaration} = deserialize_{arg['type']}(get<2>(f.getArgAtIndex({j})));\n"
                else:
                    root_ty, dimens = parse_array_name(arg['type'], idl_data['types'])
                    arg_declaration = create_cpp_array_type_string(root_ty, dimens, arg['name'])
                    function += f"      {arg_declaration};\n"
                    function += f"      deserialize_{arg['type']}(get<2>(f.getArgAtIndex({j})), ({root_ty}*){arg['name']});\n"
                arg_names.append(arg['name'])
                
                j += 1
            
            function += f"      __{fnames[i]}({', '.join(arg_names)});\n"

        function += "    } else {\n"
        function += "        __badFunction();\n"
        function += "    }\n"

    function += "  }\n"
    function += "}\n"

    func_obj = {
        "name" : "dispatchFunction",
        "signature" : "\nvoid dispatchFunction();",
        "definition" : function 
    }

    return func_obj

def create_stub_function(fname, idl_data):
    args = ""
    call_args = ""
    # If the function has any arguments...
    if len(idl_data['functions'][fname]['arguments']) > 0:

        # For each argument...
        for i in range(len(idl_data['functions'][fname]['arguments'])):
            arg_type = idl_data['functions'][fname]['arguments'][i]['type']
            arg_name = idl_data['functions'][fname]['arguments'][i]['name']
            call_args += f', {arg_name}'
            # If the argument is an array...
            if idl_data['types'][arg_type]['type_of_type'] == 'array':

                # Create the cpp-friendly version of the type name... Array_int_4_10 --> int x[4][10]
                root_ty, dimens = parse_array_name(arg_type, idl_data['types'])
                arr_ty = create_cpp_array_type_string(root_ty, dimens, arg_name)
                args += f", {arr_ty}"
            else:

                # Otherwise add it normally...
                args += f", {arg_type} {arg_name}"
        args = args[2:]
        call_args = call_args[2:]

    ret_ty = idl_data['functions'][fname]['return_type']

    function = f"\nvoid __{fname}({args}) {{\n"
    signature = function[:-3] + ';'
    if ret_ty != "void":
        function += f'    {ret_ty} result = {fname}({call_args});\n'
        function += f'    string forTheWire = \'0\' + serialize_{ret_ty}(result);\n'
    else:
        function += '    string forTheWire = "0";\n'
        function += f'    {fname}({call_args});\n'

    function += '    RPCSTUBSOCKET->write(forTheWire.c_str(), forTheWire.length());\n}\n'

    return (signature, function)

def create_stub_functions(idl_data):
    requirements = ("#include \"rpcstubhelper.h\"\n"
                    "#include \"c150debug.h\"\n"
                    f"#define FUNC_CALL_BUFFER_SIZE {FUNC_CALL_BUFFER_SIZE}\n"
                    "using namespace C150NETWORK;\n")

    funcs = [
        {
            "name" : "__badFunction",
            "signature" : "\nvoid __badFunction();",
            "definition" : ("void __badFunction() {\n"
                            "    char buf[2] = \"I\";\n"
                            "    RPCSTUBSOCKET->write(buf, 1);\n"
                            "}\n")
        },
        {
            "name" : "getNumBytesInIncomingFunctionCall",
            "signature" : "\nint getNumBytesInIncomingFunctionCall(char *buffer);",
            "definition" : ("int getNumBytesInIncomingFunctionCall(char *buffer) {\n"
                            "  unsigned int i;\n"
                            "  char *bufp;\n"
                            "  ssize_t readlen;\n"
                            "  unsigned int numBytes;\n"
                            "  bufp = buffer;\n"
                            "  for (i = 0; i < sizeof(numBytes); i++) {\n"
                            "    readlen = RPCSTUBSOCKET-> read(bufp, 1);\n"
                            "    if (readlen == 0) {\n"
                            "      break;\n"
                            "    }\n"
                            "    bufp++;\n"
                            "  }\n"
                            "  if (readlen == 0) {\n"
                            "    if (RPCSTUBSOCKET->eof()) {\n"
                            "      c150debug->printf(C150RPCDEBUG, \"Client signaled EOF before calling function\");\n"
                            "      return 0;\n"
                            "    } else {\n"
                            "      throw C150Exception(\"arithmetic.stub: unexpected zero length read without eof\");\n"
                            "    }\n"
                            "  }\n"
                            "  string numBytesStr(buffer, sizeof(numBytes));\n"
                            "  numBytes = deserialize_int(numBytesStr);\n"
                            "  return numBytes;\n"
                            "}\n")
        },
        {
            "name" : "getFunctionCallFromStream",
            "signature" : "\nint getFunctionCallFromStream(char *buffer, unsigned int bufSize);",
            "definition" : ("int getFunctionCallFromStream(char *buffer, unsigned int bufSize) {\n"
                            "  unsigned int i;\n"
                            "  char *bufp;\n"
                            "  ssize_t readlen;\n"
                            "  unsigned int numBytes;\n"
                            "  bufp = buffer + sizeof(numBytes);\n"
                            "  string numBytesStr(buffer, sizeof(numBytes));\n"
                            "  numBytes = deserialize_int(numBytesStr);\n"
                            "  for (i = 0; i < bufSize && i < numBytes; i++) {\n"
                            "    readlen = RPCSTUBSOCKET-> read(bufp, 1);\n"
                            "    if (readlen == 0) {\n"
                            "      break;\n"
                            "    }\n"
                            "    bufp++;\n"
                            "  }\n"
                            "  if (readlen == 0) {\n"
                            "    c150debug->printf(C150RPCDEBUG,\"arithmetic.stub: read zero length message, checking EOF\");\n"
                            "    if (RPCSTUBSOCKET-> eof()) {\n"
                            "      c150debug->printf(C150RPCDEBUG,\"arithmetic.stub: EOF signaled on input\");\n"
                            "    } else {\n"
                            "      throw C150Exception(\"arithmetic.stub: unexpected zero length read without eof\");\n"
                            "    }\n"
                            "  }\n"
                            "  if (i < numBytes && i >= bufSize) {\n"
                            "    throw C150Exception(\"arithmetic.stub: Incoming message was larger than bufSize\");\n"
                            "  }\n"
                            "  return numBytes;\n"
                            "}\n")
        },
    ]

    for fname in idl_data['functions']:
        sig, definition = create_stub_function(fname, idl_data)
        func_obj = {
            "name" : fname,
            "signature" : sig,
            "definition" : definition 
        }

        funcs.append(func_obj)

    funcs.append(create_dispatch_function(idl_data))

    return { "requirements" : requirements, "functions" : funcs }

def create_network_formatter():
    requirements = ("#include <stdexcept>\n"
                    "#include <tuple>\n"
                    "#include <vector>\n"
                    "#include <string>\n"
                    "#include <sstream>\n"
                    "#include <inttypes.h>\n")

    class_decl = '''
class NetworkFormatter {
  public:
    NetworkFormatter();
    NetworkFormatter(std::string offTheWire);
    ~NetworkFormatter();

    void setFunctionName(std::string name);
    std::string getFunctionName();

    void setFunctionRetType(std::string type, int typeSize);
    std::tuple<std::string, int> getFunctionRetType();

    void appendArg(std::string argTypeName, int argTypeSize, std::string argData);
    std::tuple<std::string, int, std::string> getArgAtIndex(int index);
    int getNumArgs();

    std::string getFunctionSignature();



    std::string networkForm();


  private:
    std::vector<std::tuple<std::string, int, std::string>> args;
    std::string functionName;
    int networkFormLength;
    std::tuple<std::string, int> returnType;
};
    ''' 

    class_def = '''
NetworkFormatter::NetworkFormatter() {
    functionName = "";
    returnType = make_tuple("", 0);
    networkFormLength = 0;
}

NetworkFormatter::NetworkFormatter(string offTheWire) {
    int numBytes = (*reinterpret_cast<const int*>(offTheWire.c_str()));

    offTheWire = offTheWire.substr(sizeof(int), numBytes + sizeof(int));
 
    //////
    // Find the first occurrence of ','... this character indicates the end of the function name
    size_t endOfNameIndex = offTheWire.find_first_of(",");
    if (endOfNameIndex == string::npos) {
        throw runtime_error("NetworkFormatter::NetworkFormatter(string offTheWire) -- no ',' located for the function name...");
    }
    functionName = offTheWire.substr(0, endOfNameIndex);
    // Take the substring representing the function name...
    //////

    //////
    // Find the next occurrence of '('...
    size_t endOfReturnTypeIndex = offTheWire.find_first_of("(", endOfNameIndex + 1);
    if (endOfReturnTypeIndex == string::npos) {
        throw runtime_error("NetworkFormatter::NetworkFormatter(string offTheWire) -- no '(' located for the return type name...");
    }
    string returnTypeName = offTheWire.substr(endOfNameIndex + 1, endOfReturnTypeIndex - endOfNameIndex - 1);

    // Take that substring representing the return type name...
    //////

    //////
    // Find the next occurence of ')'...
    size_t endOfReturnTypeSizeIndex = offTheWire.find_first_of(")", endOfReturnTypeIndex);
    if (endOfReturnTypeSizeIndex == string::npos) {
        throw runtime_error("NetworkFormatter::NetworkFormatter(string offTheWire) -- no ')' located for the return type size...");
    }
    int returnTypeSize = stoi(offTheWire.substr(endOfReturnTypeIndex + 1, endOfReturnTypeSizeIndex - endOfReturnTypeIndex - 1));
    // Take the subtring between the '(' and ')' as the return type size...
    //////

    //////
    // Set the return type as a tuple.
    returnType = make_tuple(returnTypeName, returnTypeSize);
    //////


    int currSectionStart = endOfReturnTypeSizeIndex + 2;
    while (currSectionStart <= (int)offTheWire.length()) {
        //////
        // Find the next occurrence of '(' in this section...
        size_t endOfArgTypeNameIndex = offTheWire.find_first_of("(", currSectionStart);

        // If no such '(' exists, then we have finished reading all of the arguments.
        if (endOfArgTypeNameIndex == string::npos) {
            break;
        }

        string argTypeName = offTheWire.substr(currSectionStart, endOfArgTypeNameIndex - currSectionStart);
        // Otherwise, take the substring from the start of the section to the '(' to be the arg type name.
        //////

        //////
        // Find the next ')'...
        size_t endOfArgSizeIndex = offTheWire.find_first_of(")", endOfArgTypeNameIndex + 1);
        if (endOfArgSizeIndex == string::npos) {
            throw runtime_error("NetworkFormatter::NetworkFormatter(string offTheWire) -- no ')' located for the arg type size...");
        }

        // Take what's between the '(' and ')' as an integer representing the size of the arg type...
        int argTypeSize = stoi(offTheWire.substr(endOfArgTypeNameIndex + 1, endOfArgSizeIndex - endOfArgTypeNameIndex - 1));

        int dataSize = argTypeSize == -1 ? sizeof(int) + deserialize_int(offTheWire.substr(endOfArgSizeIndex + 2, sizeof(int))) : argTypeSize; 
        
        // Read the next argTypeSize as the data representing the argument...
        string argData = offTheWire.substr(endOfArgSizeIndex + 2, dataSize);
        args.emplace_back(make_tuple(argTypeName, argTypeSize, argData));
        // Add the argument as a tuple to our vector.
        //////

        // Update the currSectionStart for the next iteration of the loop.
        currSectionStart = endOfArgSizeIndex + dataSize + 3;
    }   
}

NetworkFormatter::~NetworkFormatter() { }

void NetworkFormatter::setFunctionName(std::string name) {
    functionName = name;
}

std::string NetworkFormatter::getFunctionName() {
    return functionName;
}

void NetworkFormatter::setFunctionRetType(std::string type, int typeSize) {
    returnType = make_tuple(type, typeSize);
}

std::tuple<std::string, int> NetworkFormatter::getFunctionRetType() {
    return returnType;
}

void NetworkFormatter::appendArg(std::string argTypeName, int argTypeSize, std::string argData) {
    args.emplace_back(make_tuple(argTypeName, argTypeSize, argData));
}
  
std::tuple<std::string, int, std::string> NetworkFormatter::getArgAtIndex(int index) {
    if (index >= 0 && index < (int)args.size()) return args[index];
    else throw runtime_error("NetworkFormatter::getArgAtIndex -- index " + to_string(index) + " out of bounds... [0, " + to_string(args.size()) + "]");
}
  
int NetworkFormatter::getNumArgs() {
    return args.size();
}

std::string NetworkFormatter::getFunctionSignature() {
    string sig = functionName + "," + get<0>(returnType) + "(" + to_string(get<1>(returnType)) + ")";

    // For each argument in our vector...
    for (auto it : args) {
        // Add a component of the form: {,<argType>(<size>)}
        sig += "," + get<0>(it) + "(" + to_string(get<1>(it)) + ")";
    }

    return sig;
}

//////
//
// NETWORK FORM:
//
//    <functionName>,<returnType>(<size>){,<argType>(<size>),<argData>} ...
//
// Example:
//
//    int foo(float x, myStruct y)
//
//        ==
//
//    foo,int(4),float(4),xxxx,myStruct(10),yyyyyyyyyy
//
// Glossary & Other Hints:
//
// { ... } -- content between curly brackets is OPTIONAL and can be REPEATED. 
//
// <functionName> -- a string of any length representing the name of the function being called.
// 
// <returnType> -- a string representing the return type of the function... can be "void".
//
// <size> -- a non-negative integer representing the number of bytes associated with a type.
//
// <argType> -- a string representing the type of an argument to the function.
//
// <argData> -- a string representing the data intended to be interpreted as an argument to the function.
//
//////

string NetworkFormatter::networkForm() {
    // Add the required: <functionName>,<returnType>(<size>)
    string res = functionName + "," + get<0>(returnType) + "(" + to_string(get<1>(returnType)) + ")";

    // For each argument in our vector...
    for (auto it : args) {
        // Add a component of the form: {,<argType>(<size>),<argData>}
        res += "," + get<0>(it) + "(" + to_string(get<1>(it)) + ")," + get<2>(it);
    }

    res = serialize_int((int)res.length()) + res;

    return res;
}
    '''

    return { "requirements" : requirements, "class_decl" : class_decl, "class_def" : class_def }

def create_file(file_name, network_formatter_package, serializer_package, functionality_package):

    file = open(file_name, "w")
    
    file.write(f"\n\n// !! {serializer_package['name']} requirements !!\n\n")
    file.write(serializer_package["pack"]["requirements"])
    file.write(f"\n\n// !! {functionality_package['name']} requirements !!\n\n")
    file.write(functionality_package["pack"]["requirements"])
    file.write(f"\n\n// !! {network_formatter_package['name']} requirements !!\n\n")
    file.write(network_formatter_package["pack"]["requirements"])

    file.write(f"\n\n// !! {functionality_package['name']} forward declarations !!\n\n")
    for f in functionality_package["pack"]["functions"]:
        file.write(f["signature"])

    file.write(f"\n\n// !! {serializer_package['name']} forward declarations !!\n\n")
    for t in serializer_package["pack"]["functions"]:
        file.write(serializer_package["pack"]["functions"][t]["serializer"]["signature"])
        file.write(serializer_package["pack"]["functions"][t]["deserializer"]["signature"])
    
    file.write(f"\n\n// !! {network_formatter_package['name']} forward declarations !!\n\n")
    file.write(network_formatter_package['pack']['class_decl'])

    file.write(f"\n\n// !! {functionality_package['name']} functions !!\n\n")
    for f in functionality_package["pack"]["functions"]:
        file.write(f["definition"])

    file.write(f"\n\n// !! {serializer_package['name']} functions !!\n\n")
    for t in serializer_package["pack"]["functions"]:
        file.write(serializer_package["pack"]["functions"][t]["serializer"]["definition"])
        file.write(serializer_package["pack"]["functions"][t]["deserializer"]["definition"])

    file.write(f"\n\n// !! {network_formatter_package['name']} functions !!\n\n")
    file.write(network_formatter_package['pack']['class_def'])

    file.close()    

def main():
    if len(sys.argv) != 2:
        print("Error: expected file path as argument. Usage: ./rpcgenerate <path_to_idl_file>")
        exit(1)

    if re.match(".*\.idl", sys.argv[1]) == None:
        print("Error: expected a file with the .idl extension")
        exit(2)
    
    idl_name = sys.argv[1]
    index = idl_name.rfind('/')
    if index != -1:
        idl_name = idl_name[index + 1:]

    idl_set_name = idl_name[:-4]

    idl_name = idl_name.replace(".", "_").upper()

    idl_data = idl_string_to_python_object(idl_to_json(sys.argv[1]))

    serializer_package = create_serializers(idl_data["types"], idl_name, sys.argv[1])
    proxy_package = create_proxy_functions(idl_data)
    stub_package = create_stub_functions(idl_data)
    network_formatter_package = create_network_formatter()

    serp = { "name" : "Serializer Package", "pack" : serializer_package }
    proxp = { "name" : "Proxy Package", "pack" : proxy_package }
    stubp = { "name" : "Stub Package", "pack" : stub_package }
    nformp = { "name" : "Network Formatter Package", "pack" : network_formatter_package}
    create_file(f"{idl_set_name}.proxy.cpp", nformp, serp, proxp)
    create_file(f"{idl_set_name}.stub.cpp", nformp, serp, stubp)



    # for each type, create a serializer for that type

if __name__ == "__main__":
    main()